<!DOCTYPE html>
<html lang="en">
<head id="head">
  <!--Page Data-->
  <title>Schmidts.Page</title>
  <meta name="description" content="Schmidts.Page is an Alpha rendition of what will be later released as a set of tools for RPGs on the fly.">
  <link rel="shortcut icon" href="/Site-Stuff/Assets/Images/golden_bed.ico">
  <style>
    /*All of the CSS beyond the basic*/
    main .mainBtn {
        width: 80%;
    }
    main#planner-main {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
    }
    .task-card h2 {
        margin: 0 1.5vw 1.5vh 2vw;
        padding-top: .75vh;
    }
    .task-card summary {
        display: grid;
        grid-template-columns: 1fr .5fr .5fr 1.5fr 1.5fr;
        justify-items: center;
        padding-bottom: .75vh;
    }
    .task-card {
        max-width: 364px;
        margin: auto;
    }
    #taskList {
        grid-column: 1/4;
    }
  </style>
</head>
<body>
    <header id="site-wide-nav-header">
      
    </header>
    <main id="planner-main">
        <button id="" class="mainBtn" onclick="() => {console.log('editTasks()')}">Edit</button>
        <button id="newTaskBtn"  class="mainBtn" onclick="window.location.href = '/Family/Gunnar/Planner/New_Task.html'">New Task :)</button>
        <button id="reOrder" class="mainBtn" onclick="() => {console.log('reverseOrder()')}">Reverse Order</button>
        <section id="taskList"></section>
      
    </main>
    <footer id="main-footer">

    </footer>
</body>
<script src="/Site-Stuff/Scripting/Snippets/template_level_snippets.js"></script>
<script>
    function formatDuration(seconds) {
        let days = Math.floor(seconds / (3600 * 24));
        let hours = Math.floor((seconds % (3600 * 24)) / 3600);
        let minutes = Math.floor((seconds % 3600) / 60);
        let remainingSeconds = seconds % 60;
        
        let result = '';
        if (days > 0) {result += days + ':';}
        if (hours > 0 || days > 0) {if (hours < 10) {result += '0';} result += hours + ':';}
        if (minutes > 0 || hours > 0 || days > 0) {if (minutes < 10) {result += '0';} result += minutes + ':';}
        if (remainingSeconds < 10) {result += '0';}
        result += remainingSeconds;
        
        return result;
    }
    function convertTimeToSeconds(timeString) {
            let splitTimes = timeString.split(':');
            let t1 = splitTimes[0];
            let t2 = splitTimes[1];
            let t3 = splitTimes[2];
            let t4 = splitTimes[3];
        if(timeString.length > 8) {
            // days included
            return (t1 * 24 * 60 * 60 + t2 * 60 * 60 + t3 * 60 + t4) / 100
        } else if (timeString.length > 5) {
            // hours included but not days
            return (t1 * 60 * 60 + t2 * 60 + t3) / 100
        } else if (timeString.length > 2) {
            // minutes included but not hours nor days
            return (t1 * 60 + t2) / 100
        } else {
            // only seconds present
            return timeString
        }
    }

    function updateTaskList() {
        let taskList = JSON.parse(localStorage.getItem('Task-List'));

        // Get the current date/time
        let now = new Date();

        // Loop through each task in the task list
        for (let taskName in taskList) {
            let task = taskList[taskName];

            // Calculate the number of seconds since the last completion time
            let lastCompleted = new Date(task.lastCompleted);
            let secondsPassed = Math.floor((now - lastCompleted) / 1000);
            // Subtract the number of seconds passed from the original time remaining
            let timeRemainingSeconds = task.originalTimeRemaining;
            timeRemainingSeconds -= secondsPassed;
            // timeRemainingSeconds = Math.max(0, timeRemainingSeconds);


            // Convert the time remaining back to the "dd:hh:mm:ss" format if timeRemainingSeconds > 0
            let timeRemaining = '';
            if (timeRemainingSeconds > 0) {
            // timeRemaining = formatDuration(timeRemainingSeconds);
            }
            timeRemaining = timeRemainingSeconds;
            // Update the timeRemaining value in the task object
            task.timeRemaining = timeRemaining;
            if (timeRemaining >= 0) {
                task.timeRemainingVisualized = formatDuration(timeRemaining);
            } else {
                let inverseTimeRemaining = (-1 * timeRemaining)
                task.timeRemainingVisualized = formatDuration(inverseTimeRemaining)
                task.timeRemainingVisualized = "-" + task.timeRemainingVisualized;
            }
            
            // setting task failed integrated in the background changing controller
            let currentFailures = task.numberOfFailures;
            let maxFailures = 0;
            if (task.eminanceOfFailure == "Cumulative") {
                maxFailures = task.cumulaNum;
            } else if (task.eminanceOfFailure == "Immediate") {
                maxFailures = 1;
            }

            // changing background color as needed
            let needsChanged = false;
            let currentBackgroundColor = task.backgroundColor;
            if((task.taskTimeAllowed * -1) > timeRemainingSeconds) {
                // add a count to the failure count up to the max number of failures
                currentFailures += 1;
                //reset the time created to right now
                task.lastCompleted = new Date();
            } else {
                //subtract a count from the failure count down to zero as the minimum, no negative numbers
                if (currentFailures > 0) {
                    currentFailures -= 1;
                }
            }
            //setting background options in list so they can be accessed by index number later
            let backgroundColors = ["white", "lightgreen", "lightyellow", "lightsalmon", "lightpink", "grey", "black"]
            let correctBackgroundColor = 0;
            if ((task.taskTimeAllowed * 60 / 2) < timeRemainingSeconds) {
                //if time remaining until start is greater than half of what is allowed for time to finish, green
                correctBackgroundColor = 1;
            } else if ((task.taskTimeAllowed * 60 / 2) >= timeRemainingSeconds && timeRemainingSeconds > 0) {
                //if time remaining until start is less than or equal to half of the time allowed to finish, but still positive (the time to start the task hasn't happened yet), yellow
                correctBackgroundColor = 2;
            } else if (timeRemainingSeconds <= 0 && timeRemainingSeconds >= (task.taskTimeAllowed * -1)) {
                //if the time to do the task is now, but the time allowed hasn't been reached yet, salmon (colored)
                correctBackgroundColor = 3;
            } else if (timeRemainingSeconds < (task.taskTimeAllowed * -1)) {
                //if the time allowed has been surpassed, it is considered a failure now
                
            } else {
                correctBackgroundColor = 0;
            }
            // recoloring based on failures reached
            // if the failures are at half of their max or more mark it one shade darker (closer to red) than it would usually be marked, eg. green goes to yellow, yellow to red, red to black.
            let addinBackgroundNumber = 0;
            if ((task.numberOfFailures > 0)) {
                if (task.eminanceOfFailure == "Cumulative") {
                    if (task.numberOfFailures < task.cumulaNum / 2) {
                        //if number of failures is less than half of the cumulative failure limit, ignore it
                        addinBackgroundNumber = 0;
                    } else if (task.numberOfFailures >= task.cumulaNum / 2 && task.numberOfFailures < task.cumulaNum) {
                        //if number of failures greater than or equal to half of cumulative failure number but still less than full failure
                        addinBackgroundNumber = 1;
                    } else {
                        //if number of failures equals or is greater than the cumulative failure number
                        addinBackgroundNumber = 2;
                    }
                } else if (task.eminanceOfFailure == "Nugatory") {
                    //there is no effect from failing, just try again next time
                    addinBackgroundNumber = 0;

                } else {
                    //if the eminance of failure is immediate, check if the task has been failed once 
                    if (task.numberOfFailures == 1) {
                        addinBackgroundNumber = 2;
                    }
                }
            }
            correctBackgroundColor += addinBackgroundNumber;
            if (currentBackgroundColor != backgroundColors[correctBackgroundColor]) {
                task.backgroundColor = backgroundColors[correctBackgroundColor];
            }
            

            // setting the new number of failures and saving to the task object
            if (currentFailures > maxFailures) {
                currentFailures = maxFailures;
            }
            task.numberOfFailures = currentFailures;

        }

        // Save the updated task list back to local storage
        localStorage.setItem('Task-List', JSON.stringify(taskList));
    }

    
    // Populate the tasks according to the Local Storage
    function populateTasksFromLocalStorage() {
        updateTaskList();
        const taskList = JSON.parse(localStorage.getItem("Task-List"));
        const taskListSection = document.getElementById("taskList");
        taskListSection.innerHTML = "";

        // Loop through each task in the task list
        for (const task in taskList) {
            // Create a new stackable card for the task
            const taskCard = document.createElement("section");
            taskCard.classList.add("stackable-card");
            let debug = false;
            if (debug == true) {
                taskCard.innerHTML = `
                <section class="task-card" id="${taskList[task].taskName}">
                    <h2>${taskList[task].taskName}</h2>
                    <p class="task-item-debug tid-eminanceOfFailure">Eminence of Failure: ${taskList[task].eminanceOfFailure}</p>
                    <p class="task-item-debug tid-cumulaNum">Cumulative Number: ${taskList[task].cumulaNum}</p>
                    <p class="task-item-debug tid-numberOfFailures">Number of Failures: ${taskList[task].numberOfFailures}</p>
                    <p class="task-item-debug tid-taskUnits">Task Units: ${taskList[task].taskUnits}</p>
                    <p class="task-item-debug tid-taskQuantity">Task Quantity: ${taskList[task].taskQuantity}</p>
                    <p class="task-item-debug tid-customUnits">Custom Units: ${taskList[task].customUnits}</p>
                    <p class="task-item-debug tid-taskHourReset">Task Hour Reset: ${taskList[task].taskHourReset}</p>
                    <p class="task-item-debug tid-taskDayReset">Task Day Reset: ${taskList[task].taskDayReset}</p>
                    <p class="task-item-debug tid-taskTimeAllowed">Task Time Allowed: ${taskList[task].taskTimeAllowed}</p>
                    <p class="task-item-debug tid-timeRemaining">Time Remaining: ${taskList[task].timeRemaining}</p>
                    <p class="task-item-debug tid-timeRemainingVisualized">Time Remaining Visualized: ${taskList[task].timeRemainingVisualized}</p>
                    <p class="task-item-debug tid-originalTimeRemaining">Original Time Remaining: ${taskList[task].originalTimeRemaining}</p>
                    <p class="task-item-debug tid-backgroundColor">Background Color: ${taskList[task].backgroundColor}</p>
                    <p class="task-item-debug tid-lastCompleted">Last Completed: ${taskList[task].lastCompleted}</p>
                    <p class="task-item-debug tid-desc">Description: ${taskList[task].desc}</p>
                </section>
                `;
            } else {
                taskCard.innerHTML = `
                <section class="task-card" id="${taskList[task].taskName}">
                    <h2>${taskList[task].taskName}</h2>
                    <details>
                        <summary>
                            <img height="25x" width="25px">
                            <button class="task-item upBtn" id="upBtn">&#8593;</button>
                            <button class="task-item downBtn" id="downBtn">&#8595;</button>
                            <span class="task-item quantityRatioVisualized">${taskList[task].quantityCompleted}/${taskList[task].taskQuantity} ${taskList[task].customUnits}</span>
                            <span class="task-item timeRemainingVisualized">${taskList[task].timeRemainingVisualized}</span>
                        </summary>
                        <p class="task-item desc">${taskList[task].desc}</p>
                    </details>
                </section>
                `;
            }
            // Add the task card to the task list
            taskListSection.appendChild(taskCard);

            // update background colors
            document.getElementById(`${taskList[task].taskName}`).style.background = `${taskList[task].backgroundColor}`;
        }
    }

    // Call the populateTasksFromLocalStorage function to initially populate the task list
    populateTasksFromLocalStorage();

    // This is what runs the code, allowing everything to update each set time.
    // setInterval(() => {populateTasksFromLocalStorage()}, 1000);
    
    // vvvv for copy and paste testing purposes vvvv
    // console.log("huh");

</script>
</html>